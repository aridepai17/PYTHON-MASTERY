LISTS

WHAT IS A LIST
- An ordered, mutable sequence type.
- Allows heterogeneous elements and duplicates.
- Zero-based indexing with support for negative indices.

CREATION
- Literal: nums = [1, 2, 3]
- Constructor: list((1, 2, 3))
- From iterable: list("abc")
- Comprehension: squares = [n*n for n in range(5)]
- Repetition: zeros = [0] * 5
- Nested lists: grid = [[0] * 3 for _ in range(2)]  # avoids shared inner lists

CORE OPERATIONS
- Access: a[i], a[-1]
- Update: a[i] = x
- Append end: a.append(x)
- Extend: a.extend(iterable)
- Insert: a.insert(i, x)
- Remove by value: a.remove(x)           # ValueError if x not present
- Pop by index (default end): a.pop([i]) # IndexError if out of range
- Delete slice: del a[i:j]; del a[:]
- Clear all: a.clear()
- Length: len(a)
- Membership: x in a, x not in a

COMPLEXITY (AVERAGE CASE)
- Index access/assign: O(1)
- Append end: O(1) amortized; O(n) worst on resize
- Pop end: O(1)
- Insert/delete middle/front: O(n)
- Membership test (x in a): O(n)
- Slice copy of length k: O(k)

SLICING
- a[start:stop:step] returns a new list (shallow copy)
- Examples: a[1:4], a[:], a[::-1]
- Slice assignment can replace ranges: a[1:3] = ["x", "y"]

COMMON METHODS
- index(x[, start[, stop]]) -> first index of x; ValueError if not found
- count(x) -> occurrences of x
- sort(key=None, reverse=False) -> in-place, stable sort
- reverse() -> in-place reverse
- copy() -> shallow copy
- sorted(a, key=..., reverse=...) -> new sorted list (built-in function)

COPYING AND ALIASES
- Shallow copies: b = a.copy(); b = a[:]; b = list(a)
- Deep copy nested structures: import copy; b = copy.deepcopy(a)
- Assignment b = a creates an alias; mutations affect both

ITERATION PATTERNS
- for i, x in enumerate(a): ...
- for x, y in zip(a, b): ...
- Comprehensions: [f(x) for x in a if pred(x)]
- Aggregates: any(a), all(a), sum(nums), min(a), max(a)

WHEN TO USE LISTS
- Ordered collections requiring random access and in-place mutation
- Implementing stacks efficiently with append()/pop()
- Collecting results incrementally with append/extend

WHEN NOT TO USE LISTS
- Frequent inserts/removals at the left end (use collections.deque)
- Fixed-size, read-only records (use tuple)
- Keyed lookups (use dict); uniqueness without order (use set)

PYTHON EXAMPLES
nums = [10, 20, 30]
nums.append(40)           # [10, 20, 30, 40]
nums.insert(1, 15)        # [10, 15, 20, 30, 40]
val = nums.pop()          # 40; nums -> [10, 15, 20, 30]
nums[2] = 99              # [10, 15, 99, 30]
nums[1:3] = [0, 0, 0]     # [10, 0, 0, 0, 30]

PITFALLS AND TIPS
- Avoid grid = [[0]*3]*2; inner lists are shared. Prefer [[0] * 3 for _ in range(2)].
- sort() sorts in place and returns None; use sorted(a) to get a new list.
- Removing while iterating can skip elements; iterate over a copy or build a new list.
- Default mutable argument trap: def f(x, acc=None): acc = [] if acc is None else acc

KEY TAKEAWAYS
- Lists are flexible, ordered, and mutable with O(1) index access and append.
- Middle inserts/deletes are O(n); choose the right structure for your workload.
- Use comprehensions, slicing, and built-in methods for clear, Pythonic code.