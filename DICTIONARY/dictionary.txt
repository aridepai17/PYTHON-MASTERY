DICTIONARY 

WHAT IS A DICTIONARY
- A mapping of keys to values implemented as a hash table.
- Provides average O(1) access, insertion, and deletion by key.
- Conceptually unordered; since Python 3.7, iteration preserves insertion order.

KEYS AND VALUES
- Keys must be unique and hashable (immutable types like str, int, float, tuple of immutables).
- Values can be any Python object and may repeat.
- Re-assigning an existing key updates its value.

CREATION
- Literal: user = {"id": 1, "name": "Ada"}
- Constructor: dict([("a", 1), ("b", 2)])
- Comprehension: squares = {n: n*n for n in range(5)}
- From keys: dict.fromkeys(["a", "b"], 0)

CORE OPERATIONS
- Access: user["name"]           # KeyError if missing
- Safe access: user.get("age", 0)  # returns default if missing
- Insert/update: user["age"] = 30
- Existence: "age" in user
- Delete by key: del user["age"]   # KeyError if missing
- Pop by key: user.pop("age", None) # returns default if missing
- Length: len(user)
- Iterate keys: for k in user:
- Iterate values: for v in user.values():
- Iterate items: for k, v in user.items():

COMMON METHODS
- get(key, default=None): safe read with default
- setdefault(key, default=None): get if present; otherwise set to default and return it
- update(mapping_or_iterable, **kwargs): merge/update entries
- pop(key[, default]): remove and return value; default avoids KeyError
- popitem(): remove and return an arbitrary/insertion-last (3.7+) key-value pair
- keys(), values(), items(): dynamic views over the dictionary
- clear(): remove all items
- copy(): shallow copy; use copy.deepcopy for nested structures
- fromkeys(iterable, value=None): create dict with each key mapped to value

MERGING (PYTHON 3.9+)
- merged = d1 | d2            # right dict wins on key conflicts
- d1 |= d2                    # in-place update
- Older alternative: d = {**d1, **d2}

NESTED DICTIONARIES
- Access safely with chaining get:
  city = user.get("address", {}).get("city")
- Initialize if missing:
  user.setdefault("prefs", {}).setdefault("theme", "light")

DICTIONARY IN MEMORY (HASH TABLE DETAILS)
- Hash function maps a key to an index (bucket); collisions resolved by probing.
- Average-case operations are O(1); worst-case can degrade to O(n) under heavy collisions.
- The table resizes (rehashes) as it grows to keep load factor low.

USE CASES
- Lookups by unique identifier (e.g., user by id)
- Grouping/aggregation (e.g., counting with setdefault or collections.Counter)
- Caching/memoization
- Configuration/JSON-like records

PITFALLS AND TIPS
- Do not use mutable types (list, dict, set) as keys; they are unhashable and will raise TypeError.
- Avoid KeyError by using get()/setdefault()/in checks where appropriate.
- Remember copy() is shallow; nested objects are shared.
- Insertion order is preserved for iteration, but do not confuse this with sorted order.

TIME AND SPACE COMPLEXITY (AVERAGE CASE)
- Read by key: O(1)
- Insert/update: O(1)
- Delete: O(1)
- Membership test (k in d): O(1)
- Iteration over n items: O(n)
- Space: O(n)

PYTHON EXAMPLES
# create and update
profile = {"name": "Ada", "skills": ["python"]}
profile["country"] = "UK"

# safe reads
country = profile.get("country", "unknown")
lang = profile.get("lang")  # None if missing

# merging
base = {"a": 1, "b": 2}
override = {"b": 20, "c": 3}
merged = base | override   # {"a": 1, "b": 20, "c": 3}

# nested defaults
settings = {}
settings.setdefault("ui", {}).setdefault("theme", "dark")

KEY TAKEAWAYS
- Dictionaries map unique, hashable keys to arbitrary values with average O(1) operations.
- Use get/setdefault/update and views (keys/values/items) for robust, readable code.
- Prefer dicts for keyed lookups and JSON-like records; use lists when order/position is primary.

ADVANCED TOPICS
- Dict comprehensions (with conditions/transforms):
- squares = {n: n*n for n in range(10) if n % 2 == 0}
- lower_headers = {k.lower(): v for k, v in headers.items()}
- When duplicate keys occur while building, the last assignment wins.

ITERATION AND SORTING
- sorted(d) returns keys in sorted order.
- sorted(d.items(), key=lambda kv: kv[1]) sorts by value; reverse=True for descending.
- min(d, key=d.get), max(d, key=d.get) find keys with min/max values.

DICTIONARY VIEWS (DYNAMIC, SET-LIKE)
- d.keys(), d.values(), d.items() reflect live changes to the dict.
- Set operations on keys/items: d1.keys() & d2.keys(), d1.keys() | d2.keys(), d1.keys() - d2.keys().
- Snapshot with list(d.keys()) / list(d.items()) if you need a stable copy for iteration.

DEFAULTS AND SAFE UPDATES
- get(): val = d.get("threshold", 10)  # returns 10 only if missing
- If the default is expensive to compute, avoid doing it inside get():
- if "config" in d: cfg = d["config"] else: cfg = load_config()  # compute lazily
- setdefault(): d.setdefault("prefs", {}).setdefault("theme", "dark")
- setdefault() mutates the dict when the key is absent; prefer get() when you do not want mutation.

MUTATION DURING ITERATION
- Do not add/remove keys while iterating over a dict; iterate over a snapshot instead:
- for k, v in list(d.items()): ...
- To delete selectively, collect keys first: to_del = [k for k, v in d.items() if should_delete(v)]; for k in to_del: del d[k]

COLLECTIONS HELPERS
- collections.defaultdict: dd = defaultdict(list); dd[key].append(value)  # no KeyError for missing keys
- collections.Counter: counts = Counter(words); counts.most_common(5)
- collections.ChainMap: layered lookups over multiple dicts without copying.
- collections.OrderedDict: preserves order like dict (3.7+), but also supports move_to_end() and equality by order.

IMMUTABLE VIEW
- types.MappingProxyType provides a read-only view of an existing dict:
- from types import MappingProxyType; read_only = MappingProxyType(config)

COPYING AND DEEPCOPY
- Shallow copy: c = d.copy() or dict(d)  # nested objects are shared
- Deep copy: import copy; deep = copy.deepcopy(d)  # duplicates nested objects

KEY TYPES AND EQUALITY
- Keys must be hashable and compared by equality; tuples are fine if their contents are hashable.
- bool is a subclass of int; True == 1 and False == 0 share hashes, so avoid mixing them as distinct keys.
- Numeric types with equal value compare equal as keys (1 == 1.0), so later inserts overwrite earlier ones.

MERGING SHALLOW VS DEEP
- Shallow merge: d3 = d1 | d2  # (3.9+), right side wins; nested dicts are not merged recursively.
- In-place shallow merge: d1 |= d2
- For deep/nested merges, write explicit logic (e.g., recursive merge) or use third-party tools.

UNPACKING AND INTEROP
- Build from pairs: d = dict([("a", 1), ("b", 2)]) or dict(pairs)
- Unpack into call: func(**params_dict)  # keys must be valid identifiers
- Merge with unpacking (older style): combined = {**a, **b}
- JSON interop: import json; data = json.loads(text); text = json.dumps(data)

PATTERN MATCHING (PYTHON 3.10+)
- Match on mapping shape:
- match resp:
-   case {"status": 200, "data": data}: handle_success(data)
-   case {"error": msg}: handle_error(msg)

COMMON ANTI-PATTERNS
- Using mutable keys (list/dict/set) â†’ TypeError; use tuples or frozenset instead.
- Assuming iteration is sorted; if you need order guarantees beyond insertion order, use sorted().
- Modifying a dict while iterating over it; iterate a snapshot or accumulate changes first.